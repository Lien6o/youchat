package com.youchat.common.tx;

public class Design {
    /**
     *
     * 目前使用的是 可靠消息模式即 使用mq的事务消息，保证消息最终一致性。
     * 痛点：
     * 1、多个服务间的分布式事务将变得极其复杂。
     * 2、服务发出的消息语义混淆既作为分布式事务的可靠消息，又作为业务事件完成的广播消息。
     * 3、并不能实质性的完成事务的回滚，和失败处理，失败后造成业务状态的停滞。
     *
     * 使用事件溯源模式和saga模式共同解决这两个问题。
     * 1、使用saga模式同意协调分布式事务，并作出冲正接口，节点。
     * 2、使用事件溯源模式，更好的统一消息，消息结构化。同时需要保证事件的幂等 支持重试。
     * 缺点：引入TC 牺牲了少量性能 增加了一次网络请求
     *
     *
     * eg:
     * service A -> registeredEvent -> TC -> RPC/MQ
     *
     */


    /**
     * 相比与其它分布式事务框架，Seata 架构的亮点主要有几个：
     * <p>
     * 应用层基于 SQL 解析实现了自动补偿，从而最大程度的降低业务侵入性；
     * 将分布式事务中 TC（事务协调者）独立部署，负责事务的注册、回滚；
     * 通过全局锁实现了写隔离与读隔离。
     * <p>
     * 这些特性的具体实现机制其官网以及 github 上都有详细介绍，这里不展开介绍。我们看看Seata增加了哪些开销（纯内存运算类的忽略不计）：
     * 一条 Update 的 SQL，则需要全局事务 xid 获取（与 TC 通讯）、before image（解析 SQL，查询一次数据库）、after image（查询一次数据库）、insert undo log（写一次数据库）、before commit（与TC通讯，判断锁冲突），这些操作都需要一次远程通讯 RPC，而且是同步的。
     * 另外 undo log 写入时 blob 字段的插入性能也是不高的。每条写SQL都会增加这么多开销，粗略估计会增加 5 倍响应时间（二阶段虽然是异步的，但其实也会占用系统资源，网络、线程、数据库）。
     * <p>
     * 前后镜像如何生成？通过 druid 解析SQL，然后复用业务 SQL 中的 where 条件，然后生成 Select SQL 执行。
     * 为了进行自动补偿，需要对所有交易生成前后镜像并持久化，可是在实际业务场景下，这个是成功率有多高，或者说分布式事务失败需要回滚的有多少比率？
     * 这个比例在不同场景下是不一样的，考虑到执行事务编排前，很多都会校验业务的正确性，所以发生回滚的概率其实相对较低。
     * 按照二八原则预估，即为了20%的交易回滚，需要将80%的成功交易的响应时间增加5倍，这样的代价相比于让应用开发一个补偿交易是否是值得？值得我们深思。
     * <p>
     * 业界还有种思路，通过数据库binlog恢复SQL执行前后镜像，这样省去了同步undo log生成记录，减少了性能损耗，同时对业务零侵入，个人感觉是一种更好的方式。
     * <p>
     * 1）热点数据
     * Seata 在每个分支事务中会携带对应的锁信息，在 before commit 阶段会依次获取锁(因为需要将所有 SQL 执行完才能拿到所有锁信息，所以放在 commit 前判断)。相比 XA，Seata 虽然在一阶段成功后会释放数据库锁，但一阶段在 commit 前全局锁的判定也拉长了对数据锁的占有时间，这个开销比 XA 的 prepare 低多少需要根据实际业务场景进行测试。全局锁的引入实现了隔离性，但带来的问题就是阻塞，降低并发性，尤其是热点数据，这个问题会更加严重。
     * <p>
     * 2）回滚锁释放时间
     * Seata 在回滚时，需要先删除各节点的 undo log，然后才能释放 TC 内存中的锁，所以如果第二阶段是回滚，释放锁的时间会更长。
     * <p>
     * 3）死锁问题
     * Seata 的引入全局锁会额外增加死锁的风险，但如果实现死锁，会不断进行重试，最后靠等待全局锁超时，这种方式并不优雅，也延长了对数据库锁的占有时间。
     * 「Seata 的引入全局锁会额外增加死锁的风险」参考链接：https://github.com/seata/awesome-seata/blob/master/wiki/en-us/Fescar-AT.md
     * 1）对于部分采用Seata的应用，如何保证数据不脏读、幻读？
     * Seata提供了一个@GlobalLock的注解，可以提供轻量级全局锁判定的功能（不生成undo log），但还是需要集成使用Seata。
     * 2）TC在逻辑上是单点，如何做到高可用、高性能还是需要后续版本不断优化。
     * 3）单机多数据源跨服务目前不支持。
     *
     *
     * Seata 解决了分布式事务难题了吗？看你最在意哪方面了。
     *
     * 如果你希望业务尽量少感知，DB 操作简单，那它会给你带来惊喜；
     *
     * 但如果你更看重响应时间，DB 写操作较多，调用链条较长，那它可能会让失望。
     * 最后希望 Seata 开源项目越做越好！
     */
    public static final String SEATA = "SEATA";


    /**
     * 严格的ACID事务对隔离性的要求很高，在事务执行中必须将所有的资源锁定， 对于长事务来说，整个事务期间对数据的独占，将严重影响系统并发性能。
     * 因此，在高并发场景中，对 ACID 的部分特性进行放松从而提高性能，这便产生了 BASE 柔性事务。柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。
     * 通过放宽对强一致性要求，来换取系统吞吐量的提升。另外提供自动的异常恢复机制，可以在发生异常后也能确保事务的最终一致。
     *
     * 基于 XA 的分布式事务如果要严格保证 ACID，实际需要事务隔离级别为 SERLALIZABLE。
     * 由上可见柔性事务需要应用层进行参与，因此这类分布式事务框架一个首要的功能就是怎么最大程度降低业务改造成本，然后就是尽可能提高性能（响应时间、吞吐），最好是保证隔离性。
     *
     * 一个好的分布式事务框架应用尽可能满足以下特性：
     * 1.业务改造成本低；
     * 2.性能损耗低；
     * 3.隔离性保证完整。
     *
     * 基于业务补偿的Saga满足 1.2；TCC满足 2.3；Seata满足1.3。
     * 当然如果我们要自己设计一个分布式事务框架，还需要考虑很多其它特性，在明确目标场景偏好后进行权衡取舍，这些特性包括但不限于以下：
     * 业务侵入性（基于注解、XML，补偿逻辑）；
     * 隔离性（写隔离/读隔离/读未提交，业务隔离/技术隔离）；
     * TM/TC部署形态（单独部署、与应用部署一起）；
     * 错误恢复（自动恢复、手动恢复）；
     * 性能（回滚的概率、付出的代价,响应时间、吞吐）；
     * 高可用（注册中心、数据库）；
     * 持久化（数据库、文件、多副本一致算法）；
     * 同步/异步（2PC执行方式）；
     * 日志清理(自动、手动)；
     * ......
     */
}
